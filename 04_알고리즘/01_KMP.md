# KMP

KMP 알고리즘은 **임의의 문자열에서 특정 문자열을 탐색하기 위한 알고리즘**입니다. 실행시간이 매우 빠르므로 대부분의 단어 탐색 알고리즘이 KMP 알고리즘을  응용하고 있습니다.

<br>

## 기본 로직

일반적인 단어 탐색은 보통 아래의 과정을 따릅니다.

``` python
# 임의의 문자열 S와 찾고자 하는 문자열 P가 주어질 때
for i in range(len(S)):
    for j in range(len(P)):
        if S[i+j] != P[j]:
            break
  	else:
        print("탐색 성공")
```

<br>

위의 코드는 S의 각 문제에 대해 P의 길이만큼 비교문을 실행하기 떄문에 시간 복잡도는 다음과 같습니다. (N과 M은 각각 S와 P의 길이입니다)

> O(NM) 

<br>
하지만 P의 부분 문자열이 반복되는 부분이 있다면, 탐색에 실패했을 때 바로 다음 문자에 대해 탐색하는 것이 아닌 일정 부분을 건너뛴 뒤에 탐색을 할 수 있습니다. 이를 이용한 것이 KMP 알고리즘 입니다.

<br>

## 알고리즘 동작 1

본격적이 탐색을 시작하기전, 찾고자 하는 문자열 P의 LPS(Longest-Prefix & Suffix)를 탐색해야 합니다. LPS는 P의 부분 문자열에 대해 접두사, 접미사가 일치할 때 접두사, 접미사의 최대 길이를 의미합니다.

예를 들어 P가 "ABCABD" 라면, LPS는 다음과 같습니다.

| i    | P[:i+1] | 일치하는 접두사 & 접미사 | 접두사 또는 접미사의 길이 |
| ---- | ------- | ------------------------ | ------------------------- |
| 0    | A       | None                     | 0                         |
| 1    | AB      | None                     | 0                         |
| 2    | ABC     | None                     | 0                         |
| 3    | ABCA    | A                        | 1                         |
| 4    | ABCAB   | AB                       | 2                         |
| 5    | ABCABD  | None                     | 0                         |

<br>LPS를 구하는 과정은 다음과 같습니다.

1. LPS를 저장할 P의 길이만큼 크기를 가진 배열 T 을 생성합니다.
2. P의 부분문자열에 대해 아래의 과정을 수행합니다.
   1. 이전에 부분문자열에 대해 일치하는 접두사가 있었는지 확인합니다.
      1. 있었다면, 일치하는 접두사의 다음 문자와 현재 부분 문자열의 마지막 문자가 일치하는 지 확인합니다.
         1. 일치한다면 j+1을 저장합니다.
         2. 일치하지 않는다면 j를 더 이전에 일치했던 접두사의 길이로 변경합니다. 2-1-1을 다시 실행합니다.
      2. 없었다면 부분 문자열의 시작과 끝이 일치하는지 확인합니다.
         1. 일치한다면 j+1을 저장합니다.
3. T를 반환합니다.

<br>

위의 과정을 아래의 코드로 작성이 가능합니다.

``` python
def lps(p):
    l = len(p)
    t = [0] * l   
    j = 0  		 
    for i in range(1, l): 	# i -> 부분 문자열의 길이를 의미
        while j > 0 and p[i] != p[j]:  	# j > 0 -> 접두사, 접미사가 일치한 적이 있음
                                       	# p[i] != p[j] -> 접두사와 접미사의 마지막이 일치하지 않음
            j = t[j - 1]  	
        if p[i] == p[j]:
            j += 1
            t[i] = j

    return t
```

<br>

## 알고리즘 동작 2

LPS를 탐색한 후, P와 일치하는 단어를 찾기위해 아래의 과정을 수행합니다.

1. 초기 값이 0인 i가 (S의 길이 - P의 길이) 미만일 떄 까지 2~3번 과정을 반복합니다.
2. S[i]와 P[0]이 일치하지 않는다면 i를 1 증가시킵니다. 일치한다면 3번을 실행합니다.
3. 초기 값이 0인 j에 대해 S[i+j]와 P[j]가 일치하지 않을 때 까지 j를 1증가시킵니다.
4. S[i+j]와 P[j]가 전부 일치하면 S에서 P를 찾은 것이므로 i를 1 증가시킨 후 2번을 실행합니다.

<br>

위의 과정을 아래의 코드로 작성이 가능합니다.

**[Python]**

``` python
def KMP (s, p):
    i = 0
    t = lps(p)
    
    while i < len(s) - len(p):
        if s[i] != p[0]:
            i += 1
        for j in range(len(P)):
            if s[i+j] != p[j]:
                i += (1 if j == 0 else (j - t[j]))
                break
       	else: # 탐색 성공
            i += 1
            j = t[-1]
```

<br>

위의 코드는 패턴과 일치하는 문자열 탐색에 성공했을 때, 즉 t[-1]를 활용하지 않는 코드입니다.
다음은 위의 코드를 개선한, 성능이 더 좋은 코드입니다.

**[C++]**

```c++
string s;
string p;

int n = s.length();
int m = p.length();
int lps[MAX];

int j = 0;

for (int i = 0; i < n; i++) {
    // while 문을 통해서 최대한 빠르게 확인할 필요가 없는 부분을 스킵합니다.
    while (j > 0 && s[i] != p[j])
        j = lps[j - 1];
    
    // while 문을 빠져나왔다는 것은 일치하는 접두사 & 접미사가 있거나 
    // s[i] == p[j]가 참인 경우입니다.
    // 따라서 아래 코드에서 s[i] == p[j]가 참인 경우에 대한 처리를 해주어야 합니다.
    
    if (s[i] == p[j]) {
        j++;
        
        if (j == m) // 탐색 성공
            j = lps[j - 1];
    }
}
```

<br>

## 시간복잡도

N, M이 각각 S와  P의 길이를 의미한다고 가정할 때, 시간복잡도는 LPS를 구하는 시간과 S에서 P를 탐색하는 시간으로 나눌 수 있습니다.

먼저 LPS는 P의 각 문자에 대해 비교문을 실행하므로 O(M), S에서 P를 탐색하는 과정은 한 번 비교한 S의 문자에 대해 다시 비교하지 않으므로 O(N)입니다.

따라서 시간복잡도는 다음과 같습니다.

> O(N+M)

