# 삽입 정렬 (Insertion)

삽입 정렬은 탐색 과정에서 배열의 일부가 이미 정렬되어 있음을 이용하는 알고리즘 입니다.

<br>

##  기본 로직

다음은 정렬되지 않은 배열 A를 오름차순으로 정렬하는 과정입니다.

1. 두 번째 인덱스부터 시작합니다.
2. 현재 인덱스의 이전부터 첫 번째 인덱스까지 현재 원소가 삽입되야할 인덱스를 탐색합니다.
3. 탐색한 인덱스부터  현재 인덱스의 이전까지 원소의 값을 1칸씩 뒤로 이동시킵니다.
4. 탐색한 인덱스에 현재 인덱스가 가리키던 원소 값을 삽입합니다.
5. 현재 인덱스를 1 증가시킨 후 (2)~(4)과정을 반복합니다. 
6. 다음 인덱스가 없으면 종료합니다.

<br>

## 시간복잡도

각 인덱스마다 현재 인덱스부터 첫 번째 인덱스까지 원소 값을 비교하므로 시간복잡도는 다음과 같습니다.

> O(N<sup>2</sup>)

일견 선택 정렬의 Big-O와 같으므로 같은 효율처럼 보이지만, 배열의 맨 앞부터 일부 정렬되어 있다면 그 일부에 대해 비교가 1회씩 실행됩니다. 따라서 같은 길이의 배열에 대해서 역정렬이 되어있는 배열을 정렬하려는 상황이 아닌 이상 삽입 정렬이 더 나은 효율을 보여줍니다.

<br>

## 장단점

* 장점
  * 최선의 경우 O(N)라는 빠른 정렬이 가능합니다.
  * 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬법입니다.
* 단점
  * 최악의 경우 O(N<sup>2</sup>)라는 시간복잡도를 갖습니다.
  * 즉, 데이터의 상태 및 크기에 따라서 성능의 편차가 많이 발생합니다.

<br>

# Example

**[C++]**

```c++
void sort(int arr[], int n) {
	for (int i = 1; i < n; i++) {
		int key = arr[i];
		int j = i - 1;

		while (0 <= j && key < arr[j]) {
			arr[j+1] = arr[j];
			j--;
		}

		arr[j+1] = key;
	}
}


int main() {
	int arr_count = 10;
	int arr[10] = { 10, 30, 40, 50, 20, 1, 0, 4, 11, 3 };
	
    // 삽입 정렬
	sort(arr, arr_count);

    // 배열 출력
	for (int i = 0; i < arr_count; i++)
		cout << arr[i] << ' ';
	cout << endl;

	return 0;
}
```

``` 
// output
0 1 3 4 10 11 20 30 40 50
```

<br>

**[Python]**

```python
def sort(arr, n):
    for i in range(1, n):
        key = arr[i]
        j = i-1
        while 0 <= j and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key


n = 7
arr = [4, 0, 3, 7, 8, 2, 1]

sort(arr, n)
print(arr)
```

```
# output
[0, 1, 2, 3, 4, 7, 8]
```

