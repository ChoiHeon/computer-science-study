# 삽입 정렬 (Insertion)

삽입 정렬은 탐색 과정에서 배열의 일부가 이미 정렬되어 있음을 이용하는 알고리즘 입니다.

<br>

##  기본 로직

다음은 정렬되지 않은 배열 A를 오름차순으로 정렬하는 과정입니다.

1. 두 번째 인덱스부터 시작합니다.
2. 현재 인덱스의 이전부터 첫 번째 인덱스까지 현재 원소가 삽입되야할 인덱스를 탐색합니다.
3. 탐색한 인덱스부터  현재 인덱스의 이전까지 원소의 값을 1칸씩 뒤로 이동시킵니다.
4. 탐색한 인덱스에 현재 인덱스가 가리키던 원소 값을 삽입합니다.
5. 현재 인덱스를 1 증가시킨 후 (2)~(4)과정을 반복합니다. 
6. 다음 인덱스가 없으면 종료합니다.

<br>

## 시간복잡도

각 인덱스마다 현재 인덱스부터 첫 번째 인덱스까지 원소 값을 비교하므로 시간복잡도는 다음과 같습니다.

> O(N<sup>2</sup>)

일견 선택 정렬의 Big-O와 같으므로 같은 효율처럼 보이지만, 배열의 맨 앞부터 일부 정렬되어 있다면 그 일부에 대해 비교가 1회씩 실행됩니다. 따라서 같은 길이의 배열에 대해서 역정렬이 되어있는 배열을 정렬하려는 상황이 아닌 이상 삽입 정렬이 더 나은 효율을 보여줍니다.

<br>

## 장단점

* 장점
  * 최선의 경우 O(N)라는 빠른 정렬이 가능합니다.
  * 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬법입니다.
* 단점
  * 최악의 경우 O(N<sup>2</sup>)라는 시간복잡도를 갖습니다.
  * 즉, 데이터의 상태 및 크기에 따라서 성능의 편차가 많이 발생합니다.

<br>

# Example

```c++
int arr[7] = { 8, 3, 5, 1, 9, 0, 4 }
int n = 7

for (int i = 1; i < n; i++) {
    int key = arr[i];
    
    for (int j = i-1; j >= 0; j--) {
        if (arr[i] <= arr[j]) {
            for (int k = i; k > j; k--)
				arr[k] = arr[k-1];
			
          	arr[j] = key;
        }
    }
}

std::cout << arr  // expected output: [0, 1, 3, 4, 5, 8, 9]
```

