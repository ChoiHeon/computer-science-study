# Bellman-Ford

벨만-포드 알고리즘은 그래프가 주어질 때, **임의의 정점에서 나머지 정점까지의 최소 거리**를 구할 수 있는 알고리즘입니다.

다익스트라 알고리즘과의 차이점은 그래프에 **음의 가중치가 주어져도 구할 수 있다**는 점입니다. 따라서 **음의 사이클을 탐색**할 수 있다는
장점이 있습니다.

<br>

## 기본 로직

**그래프의 정점의 개수가 N개라면, 임의의 정점 V가 다른 정점까지 최단거리로 거칠 수 있는 최대 간선의 개수는 N-1개** 입니다. 따라서 모든 정점에 대해 거리를 계산하는 과정을 **N-1번 반복**하면 최단거리를 구하기 위한 **모든 경우의 수를 진행한 것과 같습니다**.

예를 들어 정점의 거리를 갱신해나가는 과정을 1 -> 4 -> 5 -> 2 -> 6 -> 8 -> ... 으로 진행했을 때, 정점 2에서 6으로 최단 경로를 2 -> 8 -> 6 이일 경우, 첫 번째 반복에서 2 -> 8과 8 -> 6을 갱신하면, 두 번째 반복에서 첫 번째 과정에서 탐색한 2 -> 6보다 2 -> 8 -> 6이 더 짧다는 것을 알 수 있습니다.

위와 같은 원리로 N-1번의 반복을 통해서 임의의 정점에 대해 나머지 정점까지의 최단 거리를 탐색할 수 있습니다. 그러나 음의 사이클이 
있을 경우,  최단 거리는 N-1번 째 반복 이후에도 계속 갱신될 것입니다(음의 사이클을 통해 가중치의 합이 계속 감소하기 때문입니다). 따라서 **만약 N번 째 반복을 실행했을 때 최단거리가 하나라도 갱신이 된다면 음의 사이클이 존재함**을 확인할 수 있습니다.

<br>

## 알고리즘 동작

1. 임의의 정점 V를 선택합니다.

2. 정점의 개수만큼의 길이를 가진 배열 D를 생성합니다. 배열의 원소는 V에서 해당 인덱스가 가리하는 정점까지의 최단 거리를 의미합니다.

3. 배열의 원소들을 매우 큰 값(무한대 or 한계값)으로 초기화합니다. V를 가리키는 인덱스의 원소는 0으로 초기화합니다.

4. 모든 정점에 대해 다음과 같은 과정을 진행합니다.

   1. 임의의 정점 U를 선택합니다.

   2. U와 연결된 정점 W에 대해 다음 식을 실행합니다. (E[I]\[J]는 정점 I과 정점 J를 잇는 간선의 길이를 의미합니다.)

      > D[W] = min(D[W], D[U] + E\[U][W])

5. 4번 과정을 N-1번 반복합니다.

6. 음의 사이클을 찾고자 한다면 4번 과정을 한 번 더 실행합니다. 이 때 최단 거리가 갱신된다는 것은 음의 사이클이 존재한다는 것과 같습니다.

<br>

## 시간 복잡도

모든 정점의 개수가 V개, 간선의 개수가 E개일 때, 모든 간선을 탐색하는 과정을 V-1번 반복하기 떄문에 시간 복잡도는 아래와 같습니다.

> O(VE)

<br>

## 최단 경로 탐색

1. 그래프의 정점의 개수만큼 길이를 가진 배열 P를 생성합니다.

2. 임의의 정점 U과 U와 연결된 정점 W에 대해 D[W]가 갱신된다면, W로 이동하기전 U를 방문했음을 기록합니다.

   > if (D[W] > D[U] + E\[U][W]) {
   >
   > ​	D[W] = D[U] + E\[U][W]
   >
   > ​	**P[W] = U**
   >
   > }

3. 모든 최단 거리 탐색이 종료됐을 때, 임의의 정점 E까지의 최단 경로는 P[E]를 역추적하면 알 수 있습니다.

<br>

## Example

문제 출처: https://www.acmicpc.net/problem/1916

``` python
n = int(input())
m = int(input())
edges = {i : [] for i in range(n)}
for _ in range(m):
    v, u, c = map(lambda e: int(e)-1, input().split())
    edges[v].append((u, c+1))
f, t = map(lambda e: int(e)-1, input().split())

# 시작 정점을 제외한 나머지 정점까지의 거리를 무한대로 초기화
dist = [float('inf')] * n
dist[f] = 0

# (정점의 개수 - 1)번 만큼 거리를 갱신
for _ in range(n-1):
    for v in range(n):
        for u, c in edges[v]:
            dist[u] = min(dist[u], dist[v]+c)


# 음수 사이클 존재 확인
for v in range(n):
    for u, c in edges[v]:
        if dist[u] > dist[v] + c:
            print("음수 사이클이 존재합니다.")
            exit(0)

print(dist[t])
```

