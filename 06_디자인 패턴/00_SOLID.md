# SOLID

SOLID는 객체지향 설계에 있어서 지켜야할 5가지 원칙을 의미합니다. 각 원칙은 다음과 같습니다.

* SRP (Single Responsibility Principle)
* OCP (Open Closed Pinciple)
* LSP (Liskov Subsitution Principle)
* ISP (Interface Segregation Principle)
* DIP (Dependency Inversion Principle)

위의 원칙을 지킴으로써 개발 기간을 단축하고 비용을 줄이는 것을 목표로 코드의 유연성, 확장성을 중요시하고 유지보수와 재사용이 용이하도록 하는 것을 목표로 합니다.

<br>

## SRP

* SRP는 **단일 책임 원칙**으로 어떤 클래스는 하나의 책임(목적, 역할, 기능)을 지녀야만 합니다. 
* 하나의 클래스가 여러 기능을 수행하면 코드가 길어지고 복잡해집니다.
  * 이 때 수정할 필요가 발생하면 시간이 많이 걸릴 수 있습니다.

<br>

## OCP

* OCP는 **개방-폐쇄 원칙**으로 클래스는 확장은 개방되어야하고 수정은 폐쇄되어야 합니다.
* 확장: 부모 클래스에서 자식 클래스를 만들 때, 자식 클래스에서 기능을 추가 및 수정할 수 있다.
* 수정: 자식 클래스를 위해서 부모 클래스를 수정할 필요는 없습니다.
* 이렇듯 추상화를 통해서 새 파생 클래스를 만드는 것을 통해 확장하는 등, 추상화는 OCP의 핵심 요소입니다.

* 만약 OCP를 지키지 않는다면 객체지향 프로그래밍의 장점인 유연서으 재사용성, 유지보수성 등을 얻기가 매우 어려워집니다.

<br>

## LSP

* LSP는 자식 클래스가 언제든 자신의 부모 클래스를 교체할 수 있다는 것입니다.
* 이는 단순히 문법적인 의미 뿐만 아니라 의미론적 관계로 성립해야 합니다.
  * q(x)를 자료형 T의 객체 x에 대해 증명할 수 있는 속성이라 가정합니다.
  * S가 T의 하위 클래스일 때, q(y)는 자료형 S의 객체 y에 대해 증명할 수 있어야 합니다.
* *Example*

  * `Shape`라는 클래스를 생성합니다.
  * 이 떄, `Shape`는 `둘레`, `넓이`, `각`을 가지고 있습니다.
  * `Shape`를 상속받은 `Rectangle` 클래스를 생성합니다.
  * 실제로 직사각형은 `둘레`, `넓이`, `각`을 가지고 있으므로 LSP가 성립합니다.
  * 이번엔 `Shape`를 상속받은 `Circle` 클래스를 생성합니다.
  * 실제 원은 `각`을 가지지 않으므로 LSP에 위배됩니다.

<br>

## ISP

* ISP는 **인터페이스 분리 원칙**으로 클라이언트가 자신과 관련이 없는 메서드를 구현하지 않아야 합니다.
* 즉, 부모 클래스의 메서드 중 자식 클래스에서 사용하지 말아야 하는 메서드가 있다면 이를 방지해야 합니다.
* *Example*
  * `게시판` 인터페이스에는 `읽기`, `수정`, `삭제` 등의 메서드가 존재합니다.
  * `게시판` 인터페이스를 상속받은 `사용자` 클래스를 생성합니다.
  * `사용자`는 `읽기`, `수정`은 가능하나 `삭제`는 불가능하므로 ISP를 위배합니다.
  * 이럴 경우, `게시판` 인터페이스를 **분리**하여 특정 역할만 이용할 수 있도록 하면 ISP에 위배되지 않고 해결할 수 있습니다.

<br>

## DIP

* DIP는 **의존성 역전 법칙**으로 어느 모듈/클래스가 보다 하위 레벨의 모듈/클래스에 의존하면 안됩니다. 즉, **추상화에 의존**해야 하며, 구체화에 의존하면 안됩니다.

* 상위 레벨의 모듈/클래스가 하위 레벨이 그것에 의존하면, 하위 레벨의 모듈/클래스의 변경에 상위 레벨의 모듈/클래스의 수정을 요구하는 관계가 될 수 있습니다.

* 이는 추상화를 통해서 메세지를 주고 받음으로서 둘 사이의 관계를 약화시켜 해결할 수 있습니다.

* *Example*

  * `자동차`라는 클래스는 툭정 타이어 객체를 필드로 가져야 합니다.
  * 이 떄 타이어의 종류는 여러가지 있을 수 있으므로, `자동차`는 특정 타이어에만 얽매여선 안됩니다.
  * 따라서 `자동차`가 타이어라는 특정 타이어에 대해 `타이어`라는 인터페이스로 접근해야 합니다.

  ``` Java
  public class Car {
      private Tire tire;
      
      public Car() {
          Tire = new Tire_AAA();
      }
  }
  ```

  ``` java
  public interface Tire() {}
  
  public class Tire_AAA implements Tire {
      ...
  }
  ```

  





