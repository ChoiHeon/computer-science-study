# TCP (Transmission Control Protocol)

* **연결지향형(Connected-oriented)** 프로토콜입니다.
  
  * 연결이 되여야만 통신이 가능합니다.
  
* **바이트 스트림(byte-stream)** 서비스를 제공합니다.

  * 논리적 의미를 갖는 메세지 스트림이 아니므로 데이터 간의 의미적 구분을 하지 않습니다.

* **세그먼트화**하여 처리합니다.

  * 바이트들을 모아서 세그먼트화하고 이를 TCP 헤더에 붙이고 순서를 제어합니다.
  * 

* **신뢰성 있는 데이터**를 전송합니다.
  
  * 데이터의 순서를 유지하기 위해 각 바이트마다 번호를 부여합니다.
  * 데이터를 재전송합니다.
  
* **1 대 1 통신(Unicast)**입니다.

  * **1 대 다 통신(Multicast)**는 **불가능**합니다.

* UDP보다 **전송 속도가 느립니다**.

  * 흐름 제어, 혼잡 제어, 오류 제어를 통해서 신뢰성을 보장하기 때문입니다.

  > **흐름제어**는 수신자의 버퍼가 오버플로우되는 것을 방지합니다.
  >
  > **혼잡제어**는 네트워크 내 패킷의 수가 과도하게 증가하는 현상을 방지합니다.
  >
  > **오류제어**는 전송된 데이터에 오류가 발생된 경우 송신 측에 오류 사실을 알려서 재전송하는 방식입니다.

* 패킷을 추적 및 관리합니다.
  
  * 데이터를 패킷 단위로 나누어 같은 목적지(IP 계층)으로 전송됩니다.
  
  > **패킷**이란 인터넷 내에서 데이터를 보내기 위한 경로 배정(라우팅)을 효율적으로 하기 위해서 데이터를 여러 개의 조각으로 나누어 전송을 하는데, 이 때 조각을 패킷이라고 합니다.
  
* 여러 컴퓨터들과 연결되어 있을 때 **가상 네트워크(회선)를 생성**합니다.

  * 송신측과 수신측을 연결하여 패킷을 전송하기 위한 **논리적 경로를 배정**한다는 의미입니다.

* Sequence Number, Ack Number를 통해서 연결에 신뢰성을 보장합니다.

  > Sequence Number는 송신측이 패킷을 전송할 때 붙이는 번호입니다.
  >
  > Ack Number는 수신측이 받은 패킷에 대해 응답하는 패킷에 붙이는 번호입니다.
  >
  > 위의 두 개를 통해서 데이터의 전송에 오류가 발생했는지 여부를 확인할 수 있습니다.

* 미리 **3-way handshaking** 방식으로 연결을 설정하고 **4-way handshaking** 방식으로 해제합니다.

* **전이중(Full-Duplex), 점대점(Point to Point)** 서비스를 제공합니다.

  > **Full-Duplex**란 두 대의 단말기가 데이터를 송수신하기 위해 동시에 각각 독립된 회선을 사용하는 통신 방식입니다. 대표적으로 전화망, 고속 데이터 통신을 들 수 있습니다.
  >
  > **Point-to-Point** 방식은 중앙 컴퓨터와 단말기를 일 대 일 독립적으로 연결하여 언제든지 데이터 전송이 가능하게 한 방식입니다. 통신망을 성형(Star)로 구성할 때 사용하며 전송할 데이터의 양과 회선 사용 시간이 많을 때 효율적입니다.

* 대부분의 웹 HTTP 통신, 이메일, 파일 전송 등에 사용됩니다.

* OSI 계층모델의 관점에서 **4계층(Transport) 계층에 해당**됩니다.

* TCP/IP는 IP위에서 동작하는 TCP를 의미합니다.

  * IP 주소를 목적으로 데이터를 TCP 방식으로 전달하는 프로토콜입니다.

<br>

## 흐름 제어 (Flow Control)

흐름제어는 송신측과 수신측의 **데이터처리 속도의 차이**를 해결하기 위한 기법입니다. 수신측의 처리가 더 빠를 경우는 문제가 없지만, 송신측이 더 빠르면 세그먼트가 수신측의 큐에 계속 쌓이기 때문에 테이터의 손실이 발행할 수 있습니다. 따라서 이럴 경우엔 **송신측의 데이터 전송을 강제로 줄일 필요가 있습니다**. 데이터 전송을 줄이는 방법은 2가지가 있습니다.

1. Stop and Wait

   매번 전송한 세그먼트에 대해 확인 응답을 받아야만 다음 패킷을 전송하는 방식입니다. Give & Take 방식이라고도 부르며 구조적으로 비효율적인 방법입니다.

2. Sliding Window

   수신측은 미리 응답없이 받을 수 있는 패킷의 개수를 설정합니다. 이를 윈도우의 크기라고 합니다. 송신측은 윈도우의 크기만큼은 수신측의 응답을 받지 않아도 세그먼트를 전송할 수 있습니다. 윈도우의 크기는 수신측이 동적으로 조절이 가능합니다. 

<br>

## 오류 제어 (Congestion Control)

송신측의 **데이터 전달**과 **네트워크의 처리속도 차이**를 해결하기 위한 기법입니다. 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달되는데 이때 라우터가 항상 자신에게 온 데이터를 처리할 순 없습니다. 이럴 경우 호스트들이 데이터를 재전송해야 하므로 오버플로우나 데이터 손실이 발생할 수 있습니다. 이런 문제를 해결하기 위해선 **송신측에서 데이터의 전송 속도를 제어해야 합니다**. 

1. AIMD (Additive Increase Multicative Decrease)

   합 증가 / 곱 감소 알고리즘이라고도 하며 처음에 패킷 하나를 보내는 것으로 시작으로 패킷이 무사히 전송된 것을 확인하면 윈도우의 크기를 1 증가시킵니다. 만약, 패킷의 전송이 실패하거나 타임 아웃이 발생하면 윈도우의 크기를 절반을 감소시킵니다.

   여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 호스트 쪽이 불리하지만 점점 공평해져가는 특성이 있습니다.

   단점으로는 초기에 높은 대역폭을 사용하지 못한다는 점과 네트워크가 혼잡해진 뒤에야 대역폭을 줄인다는 점입니다.

2. Slow Start

   Slow Start는 AMID와 마찬가지로 패킷을 하나씩 보내는 것부터 시작합니다. 이 방식은 ACK 패킷이 무사히 도착하면 윈도우 크기를 1 증가시킵니다. 즉, 윈도우 크기만큼의 패킷을 무사히 전송하면 윈도우 크기가 2배가 됩니다. 윈도우의 크기가 임계값(threshold)에 도달하기 전까진 2배로 증가하며 그 이후엔 1씩 증가시킵니다.

   혼잡현상이 발생하면 현재 윈도우의 크기를 임계값으로 설정한 뒤 1로 변경합니다. 다시 임계값에 도달하기 전까지 2개로 증가시킵니다. 혼잡현상은 타임 아웃이 발생했을 떄 인식합니다.

3. Fast Recovery

   Slow Start와 방식은 유사하지만 혼잡현상이 발생하면 윈도우 크기를 1이 아닌 절반으로 줄입니다. 이후 윈도우 크기를 1씩 증가시킵니다(AMID와 동일하게 변합니다).


<br>

## TCP 패킷의 구조

TCP 패킷의 구조는 다음과 같습니다.

* IP 헤더
* TCP 세그멘트
  * TCP 헤더
    * 포트번호
    * 소켓 주소: IP주소
    * TCP 제어 플래그: TCP 연결회선의 제어관리
    * TCP 옵션: TCP 연결 관리 기능의 확장
  * TCP 데이터