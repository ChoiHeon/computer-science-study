# Hash

* 해시(hash)는 해시 함수에 의해 반환된 데이터를 의미합니다.
* 해시 함수는 임의의 길이의 key를 고정된 길이의 hash로 변환하는 함수입니다.
  * 이러한 과정을 해싱(hashing)이라고 합니다.
* 해시 테이블은 해시를 주소 또는 색인으로 삼아서 key와 데이터(value)를 저장하는 자료구조입니다.
  * 이 때 key와 value가 저장되는 공간을 버킷 또는 슬롯이라고 부릅니다.



### 장점

* 적은 데이터로 많은 데이터를 효율적으로 관리할 수 있습니다.

* key와 value가 1대1 매칭되어 저장되기 때문에 key를 통한 value 검색을 빠르게 할 수 있습니다.

  * 평균적인 시간복잡도 = *O(1)*

* 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면, 작은 메모리로도 프로세스 관리가 가능합니다.




### 단점

* 서로 다른 키가 해시 함수에 의해서 같은 해시를 반환하면 충돌 문제가 발생할 수 있습니다.
* 순서나 관계 등을 신경써야 할 경우엔 어울리지 않습니다.
* 공간 효율성이 떨어집니다.
  * 미리 데이터를 저장해야 할 공간을 생성해야 합니다.
  * 생성한 공간이 사용되지 않을 경우 공간을 낭비하게 됩니다.
* 해시 함수에 의존도가 큽니다.
  * 해시 함수가 복잡하다면 해시를 생성하는데 오래걸리게 되고 성능 저하가 발생할 수 있습니다.



### 해시 함수 종류

* 좋은 해시 함수는 해시가 특정 값으로 치우치지 않는 함수입니다. 다음은 해시를 고르게 분포시키기 위한 해시 함수의 종류입니다.

##### 1. Division Method

* key를 테이블의 크기(=버킷의 개수)나눈 나머지를 해시로 가져옵니다.
* 테이블의 크기는 소수(prime number)이면서 2의 제곱수와 거리가 멀수록 좋습니다. (why?)
  * 이 경우 테이블의 크기가 정해진다는 단점이 있습니다.

##### 2. Mutiplication Method

* 임의의 실수 *A를* 설정합니다. (0 < A < 1)
* 숫자인 key가 *k*, 테이블의 크기가 *M*일 때, 해시는 다음과 같습니다.
  * *f(k) = (kA mod 1) x M*
* 보통 테이블의 크기를 2의 제곱수로 정합니다.
  * 2진수 연산에 최적화된 컴퓨터 구조상 이득을 얻을 수 있습니다.

##### 3. Universal Hashing

* 다수의 해시 함수를 가진 집합 H를 생성합니다.
* key를 *k*, 테이블의 크기가 M일 때, 해시는 다음과 같습니다.
  1.  키 값을 r+1개로 나눕니다. (*k0, k1, ..., kr*)
  2. 0~(*M*-1)의 수를 r+1번 뽑습니다. (*a = { a0, a1, ... , ar}* / *a*의 경우의 수= *M<sup>r+1</sup>*개)
  3. 해시 = *(k0a0 + k1a1 + ... + krar) mod M*
* 테이블의 크기가 소수인 것이 좋습니다.
* 무작위로 뽑은 해시 함수들은 프로그램 시작부터 종료시까지 유지됩니다(?)

##### 3. Mid-Square Method

* key를 제곱한 뒤, 중간의 r개의 비트를 해시로 가져옵니다.
* 상황에 따라 제곱은 여러 번 할 수 있습니다.
* 중간을 취하는 이유는 key의 top과 bottom에 의존적이지 않도록 하기 위해서입니다.



### 충돌문제 해결방법

* 다음은 서로 다른 key가 같은 해시를 가질 경우 발생하는 충돌 문제를 해결하기 위한 방법들입니다.

##### 1. Seperate Chaining

* 같은 해시를 같는 데이터들을 자료구조 형태로 저장합니다.
* 충돌에 대비해서 많은 공간을 준비할 필요가 없습니다.
* 자료구조 종류
  1. **Linked List**: 충돌이 발생한 데이터를 linked list에 추가합니다. 추가 및 삭제가 간단하지만, linked list 자체의 오버헤드가 발생할 수 있습니다.
  2. **Tree**: 충돌이 발생한 데이터를 tree (ex. red-black tree)에 추가합니다. linked list보다 메모리를 더 차지합니다.
* 자료구조 선택 기준
  * 데이터가 적으면 linked list, 많으면 tree로 저장합니다.
  * 예를 들어서 데이터 개수의 기준을 6, 8이라 가정했을 때, 데이터의 개수가 8개 이상이 되면 tree로 switching, 6개 이하가 되면 linked list로 switching 합니다.

##### 2. Open Addressing

* 해시를 통해 접근한 버킷에 이미 다른 데이터가 저장되어 있을 경우, 다음 버킷에 접근합니다.
* 다음 버킷에도 데이터가 저장되어 있을 경우 그 다음 버킷에 접근합니다.
* 이 과정을 빈 버킷에 접근하거나 해시 테이블의 범위를 벗어날 때까지 반복합니다.
  * 범위를 벗어날 경우, resizing이 발생할 수 있습니다.
* 다음 버킷에 접근하는 방법은 여러가지가 있습니다.
  1. **Linear Probing**: 정해진 폭만큼 떨어져있는 버킷에 접근합니다. 특정 해시 값의 주변이 채워져있는 <u>primary clustering</u>에 취약합니다.
  2. **Quadratic Probing**: 다음 버킷을 이동할 때 1<sup>2</sup>, 2<sup>2</sup>, 3<sup>2</sup>, ... 만큼 이동합니다. 초기 해시 값이 일치할 경우인 <u>secondary clustering</u>에 취약합니다.
* 삭제 시 다음과 같은 문제가 발생할 수 있습니다.
  1. 해시 함수를 *'key를 13으로 나눈 나머지'*, 고정폭을 1이라 가정합니다.
  2. *2, 15, 28*을 저장합니다. 전부 같은 해시를 가지므로 각각 2, 3, 4번 버킷에 저장됩니다.
     [*2: 2, 3: 15, 4: 28*]
  3. *15*를 삭제합니다.
     [*2: 2, 3: X, 4: 28*]
  4. *28*을 검색합니다.
  5. 2번 버킷은 *2*가 저장되어 있고 그 다음은 3번은 비어있으니, *28*이 저장되지 않았다고 판단합니다.
* 따라서 데이터를 삭제한 버킷을 비우지 않고 데이터를 삭제했음을 의미하는 데이터를 저장해야 합니다.
  * 이 경우, 데이터의 추가와 삭제를 반복하면 검색의 효율이 떨어질 수 있습니다.

> seperate chaining vs open addressing
>
> * open addressing은 연속된 공간을 사용하기 때문에 캐시 효율이 높습니다.
> * seperate chaining은 테이블의 확장 속도를 늦츨 수 있습니다.
> * 따라서 데이터가 적다면 open addressing, 많다면 seperate chaining을 선택합니다.

##### 3. Double Hashing

* 해시를 얻기 위한 해시 함수(*f1*)와 고정폭을 얻기 위한 해시 함수(*f2*)를 준비합니다.
* *x*의 해시 값 *f1(x)*를 바탕으로 해시 테이블에 x를 저장힙니다.
* y의 해시 값 *f1(y)*가 *f1(x)*와 같아 충돌이 발생하면, y의 고정폭 *f2(y)*만큼 이동해서 다음 버킷에 접근합니다.



### 동적 확장 (Resizing)

* 충돌 문제가 빈번하게 발생하면 성능저하로 이어지게 되므로, 데이터의 개수에 따라 테이블을 동적으로 확장할 필요가 있습니다.

* 동적 확장의 기준이 되는 데이터의 개수는 *(보통 버킷 개수 x a)*개 입니다. 

  * 이 때 *a*를 load factor라고 부릅니다.

  > open addressing의 경우, 버킷의 개수가 M, 저장하려는 데이터가 N개 이라면 ***a = N / M*** 입니다.



