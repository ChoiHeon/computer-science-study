# Git

### Git이란?

* 컴퓨터 파일의 변경사항을 추적하고 여려 명의 사용자들 간에 해당 파일의 작업을 조율하기 위한 분산 버전 관리 시스템입니다.
  * 버전 관리 시스템은 VCS(Version Control System)이라고도 합니다.
* 협업 개발에서 소스 코드 관리 용도로 사용 가능하지만, 단순히 파일의 변경사항을 추적하는데 사용할 수도 있습니다.



### GitHub와의 차이점

* 클라우드 방식으로 관리되는 버전 관리 시스템입니다.
* 오픈소스는 일정 부분 무료로 저장이 가능하지만, 아니라면 유로로 사용해야 합니다.
* 개인 프로젝트이거나 폐쇄적인 범위의 협업이라면 Git으로도 충분하지만 오픈소스를 공유하고 제3자의 의견을 듣고 싶을 경우 Github가 유용합니다.



### Git Repository

* 파일이나 폴더를 저장해 두는 곳입니다.
* 파일을 변경 이력 별로 구분되어 저장합니다.
* 깃은 원격 저장소와 로컬 저장소 두 종류의 저장소를 제공합니다

##### 1. 원격 저장소 (Remove Repository)

* 파일이 원격 저장소 전용 서버에서 관리됩니다. 
* 여러 사람들이 함께 공유하기 위한 저장소입니다.

##### 2. 로컬 저장소 (Local Repository)

* 내 PC에 파일이 저장되는 개인 전용 저장소입니다.



### Commit

* 파일 및 폴더의 추가/변경 사항을 저장소에 기록합니다.
* 이전 커밋 상태부터 현재 상태까지 변경 이력이 기록된 커밋이 생성됩니다.
* 커밋의 이름은 영문과 숫자로 이루어진 40자리 고유 이름이 붙습니다.
* 원한다면 이전 커밋 정보를 바탕으로 당시 상태로 롤백(rollback)할 수 있습니다.

##### Work Tree

* 작업 트리는 실제 작업하는 컴퓨터의 폴더를 의미합니다.

##### Index

* 커밋을 실행하기전, 작업 트리와 저장소 사이에 있는 공간입니다.
* 깃의 커밋은 작업 트리에서 바로 저장소로 가는 것이 아니라, 인덱스에 파일 상태를 기록하는 과정을 거쳐야 합니다.
* 전체 변경사항 중에서 커밋에 포함시킬 일부 변경사항만 인덱스에 등록할 수 있습니다.



### Clone

* 원격 저장소를 자신의 PC에 복사합니다.
  * 변경 이력도 함께 로컬 저장소에 복제됩니다
* 복사된 결과물은 로컬 저장소로 사용할 수 있습니다.



### Push

* 로컬 저장소에서 변경된 이력을 원격 저장소에 업로드합니다.
* 푸시 이후에 로컬 저장소와 원격 저장소가 동일한 상태가 됩니다.



### Pull

* 다른 사람이 저장한, 원격 저장소에 저장된 변경 내용을 로컬 저장소에 가져옵니다.
* 가져온 변경 내용을 그대로 로컬 저장소에 적용합니다.
* 브랜치 병합 과정에서 충돌이 발생할 경우, 직접 해결한 다음 커밋을 해야 합니다.



### Merge

* 자신의 PC에 푸시를 실행한 뒤에 다른 사람이 원격 저장소에 푸시를 했다면, 이후 자신의 푸시 요청은 거부됩니다.
* 이를 방지하기 위해 병합은 자동으로 다른 사람의 업데이트 이력을 내 저장소에 갱신해줍니다.



##### 충돌 해결

* 만약 원격 저장소와 로컬 저장소 둘 다 파일의 동일한 부분이 변경한 경우 어느 쪽을 적용할 것인지 판단할 수 없기 떄문에 자동으로 병합이 불가능합니다.
  * 대신 충돌이 발생한 부분을 '<<<<<<<'과 '>>>>>>>'의 사이로 표시해줍니다.
* 따라서 충돌이 발생한 부분은 직접 수정한 뒤, 커밋을 해야 합니다.



### Branch

* 깃의 프로젝트는 기본적으로 'master'라는 이름의 브랜치가 있고 이를 중심으로 여러 갈래의 브랜치 생성이 가능합니다. 
  * 브랜치를 생성  도중에 다른 사람의 작업에 영향을 받거나 주지 않고 작업할 수 있습니다.
* 각 팀원은 브랜치를 만들어 작업하고 필요에 따라 상의하여 브랜치를 병합(통합)합니다.



##### Integration Branch

* 통합 브랜치는 언제든 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치입니다.
* 항상 안정된 상태를 유지하는 것이 중요합니다.
  * 안정된 상태란 개발의 목적이 완벽히 구현된 상태를 의미합니다.
* 일반적으로 'master' 브랜치를 통합 브랜치로 사용합니다.



##### Topic Branch (Feature Branch)

* 만약 프로젝트에 어떤 문제(버그)가 발생해서 수정해야 하거나 새로운 기능을 추가해야 한다면, 토픽 브랜치를 생성해서 작업해야 합니다.
* 토픽 브랜치는 작업 수 만큼 생성할 수 있습니다.



##### checkout

* 현재 작업 중인 브랜치에서 다른 브랜치에서 작업을 하겠다고 선언하는 것을 의미합니다.
* 체크아웃을 실행하면 변경된 브랜치의 마지막 커밋 내용이 작업 트리에 표시됩니다.



##### HEAD

* 현재 작업 중인 브랜치의 선두 부분을 나타내는 이름입니다.
* HEAD를 이동하는 것은 브랜치를 이동하는 것과 같습니다.

> 커밋을 지정할 때, '~', ''^' 기호를 사용해 현재 커밋에서 특정 커밋의 위치를 가리킬 수 있습니다. '~'은 이전 몇 세대인지, '^'는 브랜치 병합에서 원본이 여러 개 있는 경우 몇 번째 원본인지를 지정합니다.
>
> ex) HEAD~3: 3세대 이전 커밋



##### straxh

* 변경된 내용을 커밋하지 않거나 새로 추가한 파일이 인덱스와 작업 트리에 남아있는 상태에서 체크아웃을 하면 해당 변경 내용을 전환된 브랜치에서 커밋할 수 있습니다.
* 이 과정에서 전환된 브랜치의 작업 트리에 남아있는 파일 변경 내용이 겹치게 된다면 충돌이 발생할 수 있습니다.
* 스트래시(strash)란 위 같은 상황에서 파일의 변경 내용을 일시적으로 기록해두는 영역입니다. 
  * 스트래시에 저장된 내용은 나중에 브랜치에 커밋할 수 있습니다.



###### Merge

* 여러 개의 브랜치를 하나로 병합할 수 있습니다. 
* 병합하는 방법은 여러 가지가 있을 수 있습니다.
  * A 브랜치에서 B 브랜치를 파생, A 브랜치는 어떠한 작업도 하지 않은 상태라고 가정
  * A를 단순히 B로 이동시키기만 해도 B 브랜치의 내용을 적용할 수 있습니다. 이를 fast-forward 병합이라고 합니다.
  * 옵션을 지정해서 A에 B의 내용을 적용시키는 non fast-forward 병합도 가능합니다.
    * 브랜치가 그래도 남기 때문에 브랜치 관리 및 추적에 더 유용합니다.



##### Rebase

* 파생 브랜치의 커밋을 기존의 브랜치에 새롭게 적용하는 방식입니다.
  * A 브랜치와 A에서 파생된 B 브랜치가 있을 때
  * A에서 커밋 a, b, c, d를, B에서 e, f가 수행되었다고 가정
  * rebase는 A의 현재 상태에서 커밋 e, f를 수행하는 것입니다.
    * 이 과정에서 발생하는 충돌은 직접 제어해야 합니다.
  * 이후 최종적으로 A가 진행한 커밋은 순서대로 a, b, c, d, e, f 입니다.



##### Merge vs Rebase

* merge: 변경 내용의 이력이 모두 남기 때문에 이력이 복잡해집니다.
* rebase: 이력이 단순해지지만, 기존 브랜치의 커밋 이력이 변경되기 때문에 정확한 이력이 필요하다면 사용하지 말아야 합니다.
* 만약 변경 이력을 하나로 모아서 처리하도록 운용한다면 다음과 같이 사용이 가능합니다.
  1. 토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우 rebase
  2. 통합 브랜치에 토픽 브랜치를 불러올 경우, rebase 후에 merge



##### Branch Model

* 팀에 따라서 여러 용도의 브랜치를 생성해서 사용하면 상황에 맞게 여러 작업을 동시에 진행할 수 있습니다.
* [예시](https://backlog.com/git-tutorial/kr/stepup/stepup1_5.html)



### Reference

* [backlog.com](https://backlog.com/git-tutorial/kr/)











